<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Dbstl Persistence</title>
    <link rel="stylesheet" href="gettingStarted.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.73.2" />
    <link rel="start" href="index.html" title="Berkeley DB Programmer's Reference Guide" />
    <link rel="up" href="stl.html" title="Chapter 6. Standard Template Library API" />
    <link rel="prev" href="stl_complex_rw.html" title="Store and Retrieve data or objects of complex types" />
    <link rel="next" href="section2.html" title="Change Persistence" />
  </head>
  <body>
    <div class="navheader">
      <table width="100%" summary="Navigation header">
        <tr>
          <th colspan="3" align="center">Dbstl Persistence</th>
        </tr>
        <tr>
          <td width="20%" align="left"><a accesskey="p" href="stl_complex_rw.html">Prev</a> </td>
          <th width="60%" align="center">Chapter 6. Standard Template Library API</th>
          <td width="20%" align="right"> <a accesskey="n" href="section2.html">Next</a></td>
        </tr>
      </table>
      <hr />
    </div>
    <div class="sect1" lang="en" xml:lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="stl_persistence"></a>Dbstl Persistence</h2>
          </div>
        </div>
      </div>
      <div class="toc">
        <dl>
          <dt>
            <span class="section">
              <a href="stl_persistence.html#section1">Direct Database Get</a>
            </span>
          </dt>
          <dt>
            <span class="section">
              <a href="section2.html">Change Persistence</a>
            </span>
          </dt>
          <dt>
            <span class="section">
              <a href="section3.html">Object Life Time and Persistence </a>
            </span>
          </dt>
        </dl>
      </div>
      <div class="section" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="section1"></a>Direct Database Get</h2>
            </div>
          </div>
        </div>
        <p>
Each container has a <span class="bold"><strong>begin()</strong></span> method
that produces an iterator.  All of
these <span class="bold"><strong>begin</strong></span> methods take a boolean
parameter <span class="bold"><strong>directdb_get</strong></span>,
which controls the caching behavior of the iterator.  The default
value of this parameter is true.
</p>
        <p>
If <span class="bold"><strong>directdb_get</strong></span> is true, then the
persistent object is fetched anew from the database each time the
iterator is dereferenced as a pointer by use of the star-operator
(e.g. <span class="bold"><strong>*iterator</strong></span>) or by use of the
arrow-operator
(e.g. <span class="bold"><strong>iterator-&gt;member</strong></span>).  If
<span class="bold"><strong>directdb_get</strong></span> is false, then the first
dereferencing of the iterator fetches the object from the
database, but later dereferences may return cached data.
</p>
        <p>
With <span class="bold"><strong>directdb_get</strong></span> set to true, if you call 
</p>
        <p>
</p>
        <pre class="programlisting">

(*iterator).datamember1=new-value1; 
(*iterator).datamember2=new-value2; 

</pre>
        <p>
</p>
        <p>
then the assignment to datamember1 would be lost, because the second 
dereferencing of the iterator would cause the cached copy of the object 
to be overwritten by the object's persistent data from the database.
</p>
        <p>
You also can use the arrow operator like this:
</p>
        <p>

</p>
        <pre class="programlisting">

iterator-&gt;datamember1=new-value1; 
iterator-&gt;datamember2=new-value2; 

</pre>
        <p>

</p>
        <p>
And it works exactly the same way as iterator::operator*, thus the 
same carveats apply to arrow operators too.
</p>
        <p>
One way to avoid this problem would be to create a reference to the 
object, and use it to access the object:
</p>
        <p>
</p>
        <pre class="programlisting">

container::value_type &amp;ref = *iterator;
ref.datamember1=new-value1;
ref.datamember2=new-value2;
...// more member function calls and datamember assignments
ref._DB_STL_StoreElement();

</pre>
        <p>
</p>
        <p>
The above code won't lose the newly assigned value of ref.datamember1, 
as the previous example did.
</p>
        <p>
In order to avoid these complications, you can assign to the object 
referenced by an iterator with another object of the same type like this:
</p>
        <p>
</p>
        <pre class="programlisting">

container::value_type obj2;
obj2.datamember1 = new-value1;
obj2.datamember2 = new-value2;
*itr = obj2;

</pre>
        <p>
</p>
        <p>
After this code, the new values in obj2 are stored into underlying database.
</p>
        <p>
If you have two iterators going through the same container like this:

</p>
        <pre class="programlisting">

for (iterator1 = v.begin(), iterator2 = v.begin();
     iterator1 != v.end();
     ++iterator1, ++iterator2) {
        *iterator1 = new_value;
        print(*iterator2);
}

</pre>
        <p>
	</p>
        <p>
then the printed value would depend on the value
of <span class="bold"><strong>directdb_get</strong></span> with which the
iterator had been created.
If <span class="bold"><strong>directdb_get</strong></span> is false, then the
original, persistent value would be printed; otherwise the newly
assigned value would be returned from the cache when iterator2 is
dereferenced.  This happens because each iterator has its own cached
copy of the persistent object, and the dereferencing of iterator2
would refresh iterator2's copy from the database, retrieving the value
stored by the assignment to *iterator1.
	</p>
        <p>
Alternatively, you can set directdb_get to false and call
itr2-&gt;refresh() immediately before the dereferencing of iterator2, so that
iterator2's cached value is refreshed.
	</p>
        <p>
If <span class="bold"><strong>directdb_get </strong></span>is false, 
a few of the tests in dbstl's test kit will
fail, because the above contrived case appears in several of C++ STL
tests, so the default value of <span class="bold"><strong>directdb_get </strong></span> 
paramter in the
container::begin() methods is true. If your use cases avoid such
bizzare usage of iterators, you can set it to false, to make the
iterator read operation faster.
	</p>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="stl_complex_rw.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="stl.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="section2.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Store and Retrieve data or objects of complex types  </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Home</a>
          </td>
          <td width="40%" align="right" valign="top"> Change Persistence</td>
        </tr>
      </table>
    </div>
  </body>
</html>
