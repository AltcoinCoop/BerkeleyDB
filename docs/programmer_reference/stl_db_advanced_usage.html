<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Using Advanced Berkeley DB Features with Dbstl</title>
    <link rel="stylesheet" href="gettingStarted.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.73.2" />
    <link rel="start" href="index.html" title="Berkeley DB Programmer's Reference Guide" />
    <link rel="up" href="stl.html" title="Chapter 6. Standard Template Library API" />
    <link rel="prev" href="stl_db_usage.html" title="Use Berkeley DB correctly with dbstl" />
    <link rel="next" href="stl_txn_usage.html" title="Using transactions in dbstl" />
  </head>
  <body>
    <div class="navheader">
      <table width="100%" summary="Navigation header">
        <tr>
          <th colspan="3" align="center">Using Advanced Berkeley DB Features with Dbstl</th>
        </tr>
        <tr>
          <td width="20%" align="left"><a accesskey="p" href="stl_db_usage.html">Prev</a> </td>
          <th width="60%" align="center">Chapter 6. Standard Template Library API</th>
          <td width="20%" align="right"> <a accesskey="n" href="stl_txn_usage.html">Next</a></td>
        </tr>
      </table>
      <hr />
    </div>
    <div class="sect1" lang="en" xml:lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="stl_db_advanced_usage"></a>Using Advanced Berkeley DB Features with Dbstl</h2>
          </div>
        </div>
      </div>
      <div class="toc">
        <dl>
          <dt>
            <span class="sect2">
              <a href="stl_db_advanced_usage.html#id1593590">
Using Bulk Retrieval And the DB_RMW Flag
</a>
            </span>
          </dt>
          <dt>
            <span class="sect2">
              <a href="stl_db_advanced_usage.html#id1593712">
Using Secondary Index Database And Secondary Containers
</a>
            </span>
          </dt>
        </dl>
      </div>
      <div class="sect2" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="id1593590"></a>
Using Bulk Retrieval And the DB_RMW Flag
</h3>
            </div>
          </div>
        </div>
        <p>
Bulk retrieval is an optimization option for const iterators and nonconst but 
read only iterators; DB_RMW flag is an optimization for nonconst(read-write)
iterators. </p>
        <div class="sect3" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h4 class="title"><a id="id1593819"></a> Using DB_RMW Flag</h4>
              </div>
            </div>
          </div>
          <p>
DB_RMW flag causes the underlying cursor to acquire a write lock when 
reading, to avoid deadlocks. When you want to create an iterator whose cursor has DB_RMW
flag, you should pass ReadModifyWriteOption::read_modify_write() to the container's begin()
function.
</p>
        </div>
        <div class="sect3" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h4 class="title"><a id="id1593930"></a>Using Bulk Retrieval Iterators</h4>
              </div>
            </div>
          </div>
          <p>
Bulk retrieval can minimize the number of times to access the database, thus you will
have less overhead to access the datbase. But if you are not doing serializable read, you may
read obsolete data --- part of the data you read from the bulk read buffer may have been
updated since you did the bulk retrieval. 

</p>
          <p>
If you are using an transaction handle of default isolation level 
with an iterator, you are doing serializable read, so no one else can update the bulk-retrieved data
until your iterator's cursor is closed; 
If you specify other isolation levels into the transaction
like DB_READ_COMMITTED or DB_READ_UNCOMMITTED, or you are not using a transaction
when creating the iterator, you are not doing serializable read.

</p>
          <p>
There is example code to use this feature in TestAssoc::test_bulk_retrieval_read 
method of dbstl test suite.

</p>
          <p>
You can only create a bulk retrieval iterator to move in single direction---
from begin to end, not in the opposite direction. So you can only either use operator++ to an
iterator or operator-- to a reverse iterator when using bulk retrieval.

</p>
          <p>
When using bulk retrieval, an iterator object may contain hundred of kilobytes
of data, so it is kind of expensive operation to copy it around, so use ++itr
rather than itr++ if you can, which can save a useless copy construction of 
iterator and dup/close of cursor. 

</p>
          <p>
You can configure bulk retrieval both in the const and non-const version of
the begin() in each container, since you can configure the non-const version
of begin() to return a read only cursor. This is fundamentally because the 
meaning of read only in C++ language is different from the reaonly iterator, 
the latter only means it can not be used to update database. And you can configure
the bulk retrievel buffer for this iterator when calling the begin() method, via
the BulkRetrievelItrOpt::bulk_retrievel(u_int32_t bulk_buffer_size); function.

</p>
          <p>
If you use a db_vector_iterator iterator and move it randomly rather than
sequentially, no bulk retrieval is done because there is little performance gain
to do bulk retrieval in such an access pattern.

</p>
          <p>
You can call the iterator::set_bulk_buffer function to modify the iterator's bulk 
buffer size. Note that bulk read is enabled when creating an
iterator, so users later can only modify the bulk buffer size to another value, but 
can't enable/disable bulk read while an iterator is already alive. 

</p>
        </div>
      </div>
      <div class="sect2" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="id1593712"></a>
Using Secondary Index Database And Secondary Containers
</h3>
            </div>
          </div>
        </div>
        <p>
You can use secondary index for (and only for) db_map, db_set and db_vector containers. 
Only databases for db_map, db_set and db_vector can have secondary databases, because 
db_multiset and db_multimap have duplicated keys. 
And the created database had better allow duplication, thus you should 
construct a db_multimap object to use the secondary database as a container---let's call it
a secondary container; 

</p>
        <p>
Of course if you are pretty sure that the secondary index is unique, you can 
still use a database forbidding duplicates and thus a db_map container. 

</p>
        <p>
The data_type of this db_multimap secondary container is the data_type for the 
primary db's container, e.g. we have db_map&lt;int, Person&gt;
then we can create a db_multimap&lt;size_t, Person&gt; to use a "age" secondary 
database so that we can easily get a person by age. 

</p>
        <p>
The container created from secondary database can only be used to iterate/search 
and delete, it can't be used to update or insert, but dbstl code will not enforce
this rule, while Berkeley DB does, causing an exception to be thrown.

</p>
        <p>
There is example code to use this feature in TestAssoc::test_secondary_containers
of dbstl test suite.

</p>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="stl_db_usage.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="stl.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="stl_txn_usage.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Use Berkeley DB correctly with dbstl </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Home</a>
          </td>
          <td width="40%" align="right" valign="top"> Using transactions in dbstl</td>
        </tr>
      </table>
    </div>
  </body>
</html>
