<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Use Dbstl Efficiently</title>
    <link rel="stylesheet" href="gettingStarted.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.73.2" />
    <link rel="start" href="index.html" title="Berkeley DB Programmer's Reference Guide" />
    <link rel="up" href="stl.html" title="Chapter 6. Standard Template Library API" />
    <link rel="prev" href="stl_container_specific.html" title="Dbstl Container Specific Notes" />
    <link rel="next" href="stl_memory_mgmt.html" title="Dbstl Memory Management" />
  </head>
  <body>
    <div class="navheader">
      <table width="100%" summary="Navigation header">
        <tr>
          <th colspan="3" align="center">Use Dbstl Efficiently</th>
        </tr>
        <tr>
          <td width="20%" align="left"><a accesskey="p" href="stl_container_specific.html">Prev</a> </td>
          <th width="60%" align="center">Chapter 6. Standard Template Library API</th>
          <td width="20%" align="right"> <a accesskey="n" href="stl_memory_mgmt.html">Next</a></td>
        </tr>
      </table>
      <hr />
    </div>
    <div class="sect1" lang="en" xml:lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="stl_efficienct_use"></a>Use Dbstl Efficiently</h2>
          </div>
        </div>
      </div>
      <div class="toc">
        <dl>
          <dt>
            <span class="sect2">
              <a href="stl_efficienct_use.html#id1594285">Use Iterators Efficiently</a>
            </span>
          </dt>
          <dt>
            <span class="sect2">
              <a href="stl_efficienct_use.html#id1595162">Use Containers Efficiently</a>
            </span>
          </dt>
        </dl>
      </div>
      <div class="sect2" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="id1594285"></a>Use Iterators Efficiently</h3>
            </div>
          </div>
        </div>
        <div class="itemizedlist">
          <ul type="disc">
            <li>
              <p>
Close an Iterator's Cursor As Soon As Possible
    </p>
              <p>
Each iterator has an open cursor associated with it, so when you are
finished using the iterator, it is a good habit to explicitly close
its cursor, which can potentially improve performance because of
enhanced concurrency.  Dbstl will close it when the iterator is
destroyed, but you can close it in advance of this.  If the cursor
is closed, the associated iterator can't be used any more.
    </p>
              <p>
In some functions of container classes, an iterator is used to access
the database, and its cursor is internally created by 
dbstl, so if you want to specify a non-zero flag for Db::cursor call, 
you need to call the container's set_cursor_open_flag() function to do so. 
    </p>
            </li>
            <li>
              <p>
Use Const Iterators Where Applicable
    </p>
              <p>
If your data access is read only, you are strongly recommended to use
a const iterator. In order to create a const iterator, you must use a
const reference to the container object.  For example, supposed we
have db_vector&lt;int&gt; intv(10); We must use a const
db_vector&lt;int&gt;&amp; intv_ref = intv; reference to invoke the
const begin/end functions: intv_ref.begin() will give you a const
iterator.  You can use a const iterator only to read its referenced
data elements, not updating them.  However, you should have better
performance with this iterator, e.g. via iterator::operator* or
iterator::operator-&gt;member.  
Also, using array indices like intv_ref[i] will
also perform better, and it is read only too.
    </p>
              <p>
All functions in dbstl's containers which return an iterator or data
element reference have two versions---one returns a const
iterator/reference, the other returns an iterator/reference.  If your
access is read only, choose the versions returning const
iterators/references.
    </p>
              <p>
Remember that you can only use a const reference to a container object
to call the const versions of operator* and operator[].
    </p>
              <p>
You can also use the non-const container object or its non-const 
reference to create a read only iterator by passing "true" to the 
"readonly" parameter in container's begin() method.
   </p>
            </li>
            <li>
              <p>
Use pre-increment/pre-decrement rather than
post-increment/post-decrement where possible
    </p>
              <p>
Pre-increment operations are more efficient because ++iterator avoids
two iterator copy constructions. This is true when you are using c++
standard stl iterators too.

    </p>
            </li>
            <li>
              <p>
Use Bulk Retrieval in Iterators
    </p>
              <p>
If your access pattern is going through the whole database read only,
or reading a continuous range of it, bulk retrieval can be very useful
because it returns a bunch of key/data pairs in one database call. But
beware that you can only read the returned data, you can't update
it. If you do a bulk retrieval and read the data, and some other
thread of control updates the data in the database, it means you are
reading old data unless you are using a serializable transaction.
    </p>
            </li>
          </ul>
        </div>
      </div>
      <div class="sect2" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="id1595162"></a>Use Containers Efficiently</h3>
            </div>
          </div>
        </div>
        <div class="itemizedlist">
          <ul type="disc">
            <li>
              <p>
Avoid using container methods that return references,
because they are a little more expensive.
    </p>
              <p>
To implement reference semantics, dbstl has to wrap up the data
element with the current key/data pair, and must invoke two iterator
copy constructions and two Berkeley DB cursor duplications for each
such a call. This is true of non-const versions of these
functions:
      </p>
              <div class="itemizedlist">
                <ul type="circle">
                  <li>
db_vector&lt;T&gt;::operator[]()
        </li>
                  <li>
db_vector&lt;T&gt;::front()
        </li>
                  <li>
db_vector&lt;T&gt;::back()
        </li>
                  <li>
db_vector&lt;T&gt;::at()
        </li>
                  <li>
db_map&lt;&gt;::operator[]() 
        </li>
                </ul>
              </div>
              <p>
    </p>
              <p>
There are alternatives to these functions, mainly through explicit use of iterators.
    </p>
            </li>
            <li>
              <p>
Use const container where possible.
    </p>
              <p>
The const versions of the functions listed above have less overhead
than their non-const counterparts.  Using const containers and
iterators can bring more performance when you call the const version
of the overloaded container/iterator methods. To do so,
you define a const container reference to an existing
container, and then use this reference to call the methods.  For
example, if we have a db_vector&lt;int&gt; container int_vec, then we
can define a const reference to int_vec: 
</p>
              <pre class="programlisting">
const db_vector&lt;int&gt;&amp; int_vec_ref; 

</pre>
              <p>
Then we use int_vec_ref.begin() to create a const
iterator citr. We now can use int_vec_ref to call the const versions
of member functions of the container, and use citr to access the data
read only. By using int_vec_ref and citr, we can gain better
performance.
    </p>
              <p>
It is OK to call the non-const versions of container functions that
return non-const iterators, and then assign these return values to
const iterator objects, but be careful that if you are using Berkeley
DB concurrent data store(CDS), you must set the "readonly" parameter
of each container method that returns an iterator to true. This is because
each iterator corresponds to a Berkeley DB cursor, and you need to
specify that the returned iterator will be read only (each container
method returning an iterator or a pair of iterators has a "readonly"
parameter), so that the underlying cursor is read only; Otherwise, the
cursor will be a writeable cursor, and the performance will be
degraded somewhat. If you are not using CDS, but TDS or DS or HA,
there is no distinction of read only cursor and write cursor, and you
don't need to specify the "readonly" parameter at all.
    </p>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="stl_container_specific.html">Prev</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="stl.html">Up</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="stl_memory_mgmt.html">Next</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">Dbstl Container Specific Notes </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Home</a>
          </td>
          <td width="40%" align="right" valign="top"> Dbstl Memory Management</td>
        </tr>
      </table>
    </div>
  </body>
</html>
